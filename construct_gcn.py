__doc__ = (
""" 
  Construct the graph of genes from correlation data.
  Default output: "data_dir"/"data_prefix".net
  ('data_dir' is the directory of <data_file>, 'data_prefix' is the prefix of <data_file>)
  
usage:
{f} <data_file> <dict_file> <max_neg> <min_pos> [-c] [-m (<from> <to>)] [-o <output_file>]
{f} -h | --help

options:
  -h, --help               show this help message and exit.
  <data_file>              specify the data file containing correlation data (gene x gene matrix).
  <dict_file>              specify the dictionary file.
  <max_neg>                specify the maximum negative value of correlation.
  <min_pos>                specify the minimum positive value of correlation.
  -c                       set circular coordinate flag
  [-m (<from> <to>)]       input files (<from><data_file> .. <to><data_file>) generated by compute_gcm.py with multi-mode. 
  -o <output_file>         specify the output file.
""").format(f=__file__)

import math
import numpy as np
import pandas as pd
import networkx as nx
from mypajek import *
import os
import sys
from docopt import docopt
from schema import Schema, SchemaError, And, Or, Use, Optional


# define the schema for args.
schema = Schema({
  '--help': bool,
  '<data_file>': Use(str),
  '<dict_file>': Use(str),
  '<min_pos>': Use(float),
  '<max_neg>': Use(float),
  '-c': bool,
  '-m': bool,
  Optional('-o'): Use(str),
  '<from>': Or(None, And(Use(int), lambda n: 0 <= n), error="<from> should be a positive integer"),
  '<to>': Or(None, And(Use(int), lambda n: 0 <= n), error="<from> should be a positive integer"),
})

# constants for default coordinates
max_position = 200000000
unit_X = 1.0/max_position
chr_num = 24
unit_Y = 1.0/chr_num

# constants for circular coordinates
center = 0.5
radius = 0.5
start = 0.5 * np.pi
clockwise = 1

def add_vertices(g, allgenes, gene_dict):
  cols = len(allgenes)
  # we will use only type==Normal genes. 
  # set for manage them.
  normals = set()
  for i in range(cols):
    gene = allgenes[i]
    # sometimes gene includes two names whose seperator is a comma.
    # anyway, we use the first name only.
    first_gene = (gene.split(','))[0]
    #print(firstGene)
    try:
      gene_data = gene_dict.loc[first_gene]
    except KeyError:
      #print(first_gene + ' is not found in the dictionary')
      continue
    gene_type = gene_data['type']
    gene_c1 = gene_data['c1']
    # 'c2' is unused currently 
    #gene_c2 = gene_data['c2']
    gene_start = gene_data['start']
    # 'end' is unused currently
    #gene_end = gene_data['end'] 
    # print('gene data: name: {0}, type: {1}, c1: {2}'.format(first_gene, gene_type, gene_c1))
    # we will use only type==Normal, Xtype, Ytype genes.
    if gene_type == 'Xtype':
      gene_c1 = 23
    elif gene_type == 'Ytype':
      gene_c1 = 24
    if gene_type in ['Normal', 'Xtype', 'Ytype']:
      normals.add(gene)
      if not circularmode:
        gene_X = gene_start * unit_X
        gene_Y = 1.0 - gene_c1 * unit_Y
      else:
        diff = gene_c1 + unit_X * gene_start
        theta = start - (clockwise * 2.0 * np.pi * diff/ (chr_num + 1))
        gene_X = center + radius * math.cos(theta)
        gene_Y = center + radius * math.sin(theta) 
      g.add_node(gene, x = round(gene_X, 5), y = round(gene_Y, 5))
  return (g, normals)

def convert_corrmatrices2graph(max_neg, min_pos, corr_file, dict_file, is_multi=False, index_from=0, index_to=0, circularmode = False):
  print(dict_file)
  gene_dict = pd.read_csv(dict_file, index_col=0)
  g = nx.Graph()
  totalrows = 0
  corr_dir, corr_filename = os.path.split(corr_file)
  if not is_multi:
    index_from = 0
    index_to = 0 
  for h in range(index_from, (index_to+1)):
    if not is_multi:
      print(corr_file)
      mat = pd.read_csv(corr_file, header=0, index_col=0)
    else:
      id_corr_file = corr_dir + '/' + str(h) + '_' + corr_filename
      print(id_corr_file)
      mat = pd.read_csv(id_corr_file, header=0, index_col=0)
    
    allgenes = mat.columns
    rows = len(mat)
    cols = len(allgenes)
    print("{0} rows, {1} cols".format(rows, cols))
    if h == index_from:
      g, normals = add_vertices(g, allgenes, gene_dict)
      #print('vertices ok')  
    for i in range(rows):
      gene_i = mat.index.values[i] #allgenes[i]
      #print(gene_i)
      if gene_i not in normals:
        continue
      for j in range(totalrows+i+1, cols): #muda ooshi
        corr_value = mat.iat[i,j]
        #if corr_value >= min_pos:
        #  print("({0}, {1}): {2}".format(i, j, corr_value))
        if max_neg >= corr_value or min_pos <= corr_value:
          gene_j = allgenes[j]
          if gene_j in normals:
            g.add_edge(gene_i, gene_j, weight=round(corr_value, 5))
    totalrows += rows
  return(g)

if __name__ == '__main__':
  args = docopt(__doc__)
  
  try:
    args = schema.validate(args)
  except SchemaError as error:
    print(error)
    sys.exit(1)
  print(args)
  
  circularmode = False
  if args['-c']:
    circularmode = True
  if args['-m']:
    index_from = args['<from>']
    index_to = args['<to>']
  else:
    index_from = 0
    index_to = 0
  data_file = args['<data_file>']
  data_dir, data_filename = os.path.split(os.path.abspath(data_file))
  data_file_without_ext, data_type = os.path.splitext(data_filename)
  result_file = args['-o']
  if result_file == 'None' or result_file == '':
    suf = '.net'
    if circularmode:
      suf = '_c.net'
    result_file = data_dir + '/' + data_file_without_ext + suf
  
  
  min_pos = args['<min_pos>']
  max_neg = -1.0 * args['<max_neg>']

  g = convert_corrmatrices2graph(max_neg, min_pos, data_file, args['<dict_file>'], args['-m'], index_from, index_to, circularmode)
  nx.write_pajek(g, result_file)
  print("n = {0}, m = {1}".format(g.number_of_nodes(), g.number_of_edges()))
